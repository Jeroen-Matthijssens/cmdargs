<!DOCTYPE html>
<html>

<head>
	<link rel="stylesheet" href="http://yandex.st/highlightjs/7.5/styles/default.min.css">
	<link rel="stylesheet" href="style.css">
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="http://yandex.st/highlightjs/7.5/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
<h1>Main Goal</h1>

<p>Give a consistent way of parsing command line options. This means describing what is and
is not allowed by the conventions we well provide here. A lot of inspiration is drawn from
the git command line interface.</p>

<h2>General Overview</h2>

<h3>General Options Layout</h3>

<p>All options should have at least a long version. Meaning there should be a way to specify
an option by typing out whole words. If possible a short version (a single character)
should be provided as well. Short options can be combined with each other by writing
one after the other.</p>

<p>Short options are case sensitive, long options are not. The words in long options are
separated with a dash (<code>-</code>).</p>

<p>When necessary, parsing of options can be stopped by providing a <code>--</code> on the command line.
Everything after a <code>--</code> will not be parsed as options. This can be useful for instance
when a path name starts with a dash..</p>

<pre><code class="bash">$ command -s
$ command -stv
$ command --long-option --other-long-option
$ command --long-option -s -- -path/starts/with/dash
</code></pre>

<h3>Sub Commands</h3>

<p>Sub commands can be used. Sub commands can be nested if necessary <code>$ command sub deepsub</code>.
Either the command (either the main command or a subcommand) always uses subcommands, or
it never uses any.</p>

<p>A subcommand is a single word and is case insensitive.</p>

<p>The first non option, non option value string that is found is treated as the subcommand.
Commands can not occur after a <code>--</code>.
Option can be given to both the subcommand and the command itself</p>

<pre><code class="bash">$ command --command-option sub --sub-command-option -- notsub
</code></pre>

<h3>Assigning Values To Options.</h3>

<p>As a convention short options allow values directly after the option. When more than one
short option is used, you can not group a short option with a value together with other
short options.</p>

<p>The first example is correct, the second and third example should give an error.</p>

<pre><code class="bash">$ command -st -v value -w other
$ command -stv value
$ command -s=value
</code></pre>

<p>Long options can be assigned values by adding an equals sign and the value.</p>

<pre><code class="bash">$ command --long-option=value --other-long-option=other
</code></pre>

<p>When there is no equals sign the value will be interpreted as either the subcommand or the
first non option argument.</p>

<h3>Value lists</h3>

<p>If an option can have a value, it can have multiple values. There are two ways to give
mulitple values. The values can be given one at a time by repeating the option and then
the next value in the list. This should work with both long and short options.</p>

<pre><code class="bash">$ command -l first -l second -l third
$ command --long-option=first --long-option=second
</code></pre>

<p>An other way is to specify the values in one go, this only works with short options. The
values are seperated by a comma. No spaces are allowed in this list.</p>

<pre><code class="bash">$ command --value-option=first,second,third
</code></pre>

<h3>Boolean Options</h3>

<p>Allow for boolean options. As a convention allow the <code>not-</code> prefix to negate the option
when it is a boolean value. Do not allow <code>--not-option=false</code> or <code>--not-option=true</code>.</p>

<pre><code class="bash">$ command --enabled
$ command --not-enabled
$ command --enabled=true
$ command --enabled=false
</code></pre>

<h2>ordering</h2>

<p>The only order that is preserved is that of multiple values being assigned to a single
option. There is no way to infer which option of a pair came before the other. This means
that constructions such as:</p>

<pre><code class="bash">$ command --include=path/to/file --not --include=path/to/file/sub
</code></pre>

<p>can not be given the meaning &quot;include everthing under <code>path/to/file</code> but not what is
under <code>path/to/file/sub</code>&quot;. The above example has the <code>--not</code> option set and the
<code>--include</code> option, furthermore the <code>--include</code> option has two value assigned:
<code>path/to/file</code> and <code>path/to/file/sub</code>. But there is no way to know where in the list of
values for <code>--include</code> the <code>--not</code> option would have appeared.</p>

<h1>Constructing a scheme</h1>

<p>Keeping around references to the option that are valid minimized the risk of mistyping
representations of the options.</p>

<pre><code class="java">public class Options {
    public static final ValueOption&lt;String&gt; msg = new StringOption (&quot;message&quot;, &quot;m&quot;, true);
    public static final ValueOption&lt;Boolean&gt; print = new BooleanOption (&quot;print&quot;, &quot;p&quot;);
    public static final Option printAll = new BasicOption (&quot;print all&quot;, &quot;P&quot;);

    // Uses above values, so this has to go after the options definitions
    public static final CommandScheme scheme = Options.createScheme ();

    private static CommandScheme createScheme () {
        return CommandSchemeBuilderFactory.newInstance ()
            .addOption (Options.printAll)
            .addOption (Options.print)
            .addOption (Options.msg)
            .buildScheme ();
    }
}
</code></pre>

<p>A RuntimeException will be thrown if the parsing of the arguments has failed. The parser
can print a usefull message to <code>System.out</code> when something goes wrong.</p>

<pre><code class="java">public static void main (String [] args) {
    Parser parser = ParserFactory.newInstance (Options.scheme);

    try { ParsedCommand parsed = parser.parse (args); }
    catch (CommandLineException exception) { parser.printError (); }

    new Main (parsed).run ();
}
</code></pre>

<p>As an example we just print out what was given to the <code>--message</code> option, but only if the
<code>--print</code> option is given</p>

<pre><code class="java">public void run () {
    if ( parsed.hasOption (Options.printAll) ) { printAll (); }
    else if ( ! parsed.hasOption (Options.print) ) { return; }
    else if ( parsed.getOptionValue (Options.print)) { printFirst (); }
}

public void printAll () {
    List&lt;String&gt; messages = parsed.getOptionValues (Options.msg);
    for ( String message : messages ) { printSingle (message); }
}

public void printFirst () {
    String message = parsed.getOptionValue (Options.msg);
    printSingle (message);
}

public void printSingle (String msg) {
    System.out.println (msg);
}
</code></pre>

<p>With the above running the application produces the following.</p>

<pre><code class="bash">$ java -jar command.jar --message=&#39;Hello World!&#39; --print
Hello World!
$ java -jar command.jar --message=&#39;Hello World!&#39; --no-print
$ java -jar command.jar --message=&#39;Hello World!&#39;
$ java -jar command.jar --print --message=&#39;Hello World!&#39;
Hello World!
$ java -jar command.jar --message=Hello,World --print
Hello
$ java -jar command.jar --message=Hello,World --print-all
Hello
World
</code></pre>

<pre><code class="java">$ java -jar command.jar --print
Error: missing required argument `--message`!
$ java -jar command.jar --message
Error: missing value for `--message`!
</code></pre>

<h1>Classes</h1>

<h2>Option</h2>

<p>An Interface describing the options a valid option on the commandline.</p>

<pre><code class="java">public interface Option {
    public String getRepresentation ();
    public String getDescription ();
    public boolean hasShortRepresentation ();
    public String getShortRepresentation ();

    public boolean matches (String representation);
    public boolean isRequired ();
}
</code></pre>

<p>When calling <code>option.getRepresentation ()</code> the string that is returned is always the
representation with dashes (<code>long-option</code> instead of <code>long option</code>).</p>

<pre><code class="java">public interface ValueOption&lt;T&gt; extends Option {
    public T validateValue (String value) throws WrongValueException;
}
</code></pre>

<p>A couple of implementations are provided. <code>BasicOption</code> implements only the <code>Option</code>
interface. <code>BooleanOption</code>. <code>DecimalValueOption</code>, <code>NumberValueOption</code>, <code>PathValueOption</code>
and <code>StringValueOption</code> implement the <code>ValueOption</code> interface.</p>

<p>They all have constructors with a long representation and a constructor with both a long
and short representation. You can provide an extra boolean indicating whether the option
is required or not. By default options are not required.</p>

<pre><code class="java">Option basic = new BasicOption (&quot;basic option&quot;);
ValueOption&lt;Boolean&gt; bool = new BooleanOption (&quot;required boolean&quot;, true);
ValueOption&lt;Long&gt; long = new NumberValueOption (&quot;number&quot;, &quot;n&quot;);
ValueOption&lt;String&gt; string = new StringValueOption (&quot;required string&quot;, &quot;s&quot;, true);
</code></pre>

<p>Options should equal each other if they have the same long representation. If the long
representation is the same, the short representations should also be the same. Long
representations can be written either with spaces or with dashes. Two leading dashes are
also stipped.</p>

<pre><code class="java">Option spaces = new BasicOption (&quot;long option&quot;);
Option dashes = new BasicOption (&quot;long-option&quot;);
Option leading = new BasicOption (&quot;--long-option&quot;);

assertThat (spaces.equals (dashes), is (true));
assertThat (spaces.equals (leading), is (true));
</code></pre>

<h2>Argument</h2>

<pre><code class="java">public interface Argument&lt;T&gt; {
    public String getRepresentation ();
    public int getPosition ();
    public boolean isRequired ();
    public boolean matches (String represenation);
    public Validator&lt;T&gt; getValidator ();
}
</code></pre>

<h2>SubCommand</h2>

<p>The command should return a <code>CommandScheme</code> that represents the options, commands or
arguments that can follow this command.</p>

<pre><code class="java">public interface Command {
    public boolean matches (String representation);
    public String getRepresentation ();
    public CommandScheme getCommandScheme ();
}
</code></pre>

<p>One implementation is provided (<code>SubCommandImpl</code>). It can be instantiated with a string
representing the subcommand, or with a string and an options scheme.</p>

<pre><code class="java">SubCommand command = new SubCommandImpl (&quot;sub&quot;);

OptionScheme scheme = new CustomOptionsScheme ();
SubCommand command = new SubCommandImpl (&quot;sub&quot;, scheme);
</code></pre>

<h2>CommandScheme</h2>

<p>This class is used to build up a scheme that is used to validate commandline arguments
against. It should also provide a nice <code>toString ()</code> method, to output a useful
description of the options that are allowed, and what they do.</p>

<p>When a subcommand is used, the paser should handle two schemes, the one used for the
global command, and the scheme for the subcommand. The structure for both is the same.</p>

<pre><code class="java">public interface CommandScheme {
    public boolean hasCommands ();
    public boolean hasArguments ();

    public boolean hasOption (Option option);
    public boolean hasOption (String representation);
    public Option getOption (String representation);

    public boolean hasCommand (Command command);
    public boolean hasCommand (String command);
    public Command getCommand (String command);

    public boolean hasArgument (Argument&lt;?&gt; argument);
    public boolean hasArgument (String argument);
    public Argument&lt;?&gt; getArgument (String representation);
    public List&lt;Argument&lt;?&gt;&gt; getArguments ();
}
</code></pre>

<h2>ParsedCommand</h2>

<pre><code class="java">public interface ParsedCommand {
    public boolean hasCommand ();
    public Command getCommand ();
    public ParsedCommand getParsedCommand ();

    public boolean isOptionPresent (Option option);
    public &lt;T&gt; T getOptionValue (ValueOption&lt;T&gt; option);
    public &lt;T&gt; List&lt;T&gt; getOptionValues (ValueOption&lt;T&gt; option);

    public boolean isArgumentPresent (Argument&lt;?&gt; argument);
    public &lt;T&gt; T getArgumentValue (Argument&lt;T&gt; argument);

    public String [] getArgumentValues ();
}
</code></pre>

<p>The <code>getParsedCommand ()</code> only returns something sensible if <code>hasCommand ()</code> is true. It
returns a new instance of <code>ParsedCommand</code> that represents the options and arguments or
commands that were parsed for the command returned by <code>getCommand ()</code>.</p>

<p>When using the <code>getOptionValue ()</code> method, the option (or representation of the option) has te
refer to an option that supports that type of value. If this is not the case the call will
result in a <code>ClassCastException</code>.</p>

<h2>Parser</h2>

<p>An Interface for parsers.</p>

<pre><code class="java">public interface Parser {
    public void parse (String [] args);
    public boolean hasSubCommand ();
    public String getSubCommand ();
    public ParsedOptions getOptions ();
    public ParsedOptions getGlobalOoptions ();
}
</code></pre>

<p>One parser implementation is provided (<code>ParserImpl</code>).</p>

<p>It can be instantiated with a list of subcommands. In this case there are no global
options allowed. Recall that when a subcommand can be used, a subcommand has to be used
for all valid <code>String [] args</code> sequences.</p>

<pre><code class="java">List&lt;SubCommand&gt; commands = buildSubCommandList ();
Parser parser = new ParserImpl (commands);
</code></pre>

<p>It can be instantiated with a single options scheme. In this case no
subcommands are allowed and the options scheme will be treathed as the global options
scheme.</p>

<pre><code class="java">OptionScheme scheme = new CustomOptionScheme ();
Parser parser = new ParserImpl (scheme);
</code></pre>

<p>It can be instantiated with an options scheme and a list op subcommands. This
is the same as a list of subcommands except that global options are now allowed, and are
specified by the options scheme given to <code>ParserImpl</code>.</p>

<pre><code class="java">List&lt;SubCommand&gt; commands = buildSubCommandList ();
OptionScheme scheme = new CustomOptionScheme ();
Parser parser = new ParserImpl (scheme, commands);
</code></pre>

<h1>Example</h1>

<p>Suppose we want the following command to be valid.</p>

<pre><code class="bash">$ command -st -u short sub --long-option=long path/to/file
</code></pre>

<p>We first need to specify that these options are valid. For this we build an
<code>OptionScheme</code>. This will contain all the information needed to validate and parse the
command line arguments.</p>

<pre><code class="java">SchemeBuilder schemeBuilder = new SchemeBuilder ();

schemeBuilder.add (new BasicOption (&quot;long option&quot;));
schemeBuilder.add (new BasicOption (&quot;short option&quot;, &quot;s&quot;));
schemeBuilder.add (new ValueOption (&quot;with value&quot;));
schemeBuilder.add (new BooleanOption (&quot;enable&quot;);
schemeBuilder.add (new Argument (&quot;path&quot;, 0));

OptionScheme scheme = schemeBuilder.buildScheme ();
</code></pre>

<p>When Using this in a program it could look something like this.</p>

<pre><code class="java">public static main (String [] args) {
    OptionScheme scheme = buildScheme ();
    Parser parser = new ParserImpl (scheme);

    parser.parse (args);
    ParsedOptions options = parser.getOptions ();

    assertThat (options.isPresent (&quot;long option&quot;), is (true));
    assertThat (options.getValue (&quot;long option&quot;), is (&quot;long&quot;));

    assertThat (options.isPresent (&quot;s&quot;), is (true));
    assertThat (options.getValue (&quot;s&quot;), is (&quot;short&quot;));

    assertThat (options.getArg (0), is (&quot;path/to/file&quot;));
    assertThat (options.getArg (&quot;path&quot;), is (&quot;path/to/file&quot;));
}

private static OptionScheme buildScheme () {
    SchemeBuilder schemeBuilder = new SchemeBuilder ();
    ...
    return scheme;
}

</code></pre>

<p>When parsing the following command.</p>

<pre><code class="bash">$ command --long-option sub --sub-option
</code></pre>

<pre><code class="java">public static main (String [] args) {
    OptionScheme scheme = buildScheme ();
    Parser parser = new ParserImpl (scheme);

    parser.parse (args);

    assertThat (parser.hasCommand (), is (true));
    assertThat (parser.getCommand (), is (&quot;sub&quot;));

    ParsedOptions options = parser.getOptions ();
    assertThat (options.isPresent (&quot;long option&quot;), is (false));
    assertThat (options.isPresent (&quot;sub option&quot;), is (true));

    ParsedOptions subOptions = parser.getGlobalOptions ();
    assertThat (subOptions.isPresent (&quot;long option&quot;), is (true));
    assertThat (subOptions.isPresent (&quot;sub option&quot;), is (false));
}

public static OptionScheme buildScheme () {

}
</code></pre>

<h1>Possible extras?</h1>

<ul>
<li>A way to indicate that one of a group of options is mandatory, for instance such as the
tar command. It needs either an x, c, ... .</li>
</ul>
</body></html>
