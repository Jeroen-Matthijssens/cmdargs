<!DOCTYPE html>
<html>

<head>
	<link rel="stylesheet" href="http://yandex.st/highlightjs/7.5/styles/default.min.css">
	<link rel="stylesheet" href="style.css">
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="http://yandex.st/highlightjs/7.5/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
<h1>Main Goal</h1>

<p>Give a consistent way of parsing command line options. This means describing what is and
is not allowed by the conventions we well provide here. A lot of inspiration is drawn from
the git command line interface.</p>

<h2>General Overview</h2>

<h3>General Options Layout</h3>

<p>All options should have at least a long version. Meaning there should be a way to specify
an option by typing out whole words. If possible a short version (a single character)
should be provided as well. Short options can be combined with each other by writing
one after the other.</p>

<p>Short options are case sensitive, long options are not. The words in long options are
separated with a dash (<code>-</code>).</p>

<p>When necessary, parsing of options can be stopped by providing a <code>--</code> on the command line.
Everything after a <code>--</code> will not be parsed as options. This can be useful for instance
when a path name starts with a dash..</p>

<pre><code class="bash">$ command -s
$ command -stv
$ command --long-option --other-long-option
$ command --long-option -s -- -path/starts/with/dash
</code></pre>

<h3>Sub Commands</h3>

<p>Sub commands can be used. A single subcommand is allowed <code>$ command sub</code>. Either the
command always uses subcommands, or it never uses any. The first non option string that is
found is treated as the subcommand. Option can be given to both the subcommand and the
command itself</p>

<pre><code class="bash">$ command --command-option sub --sub-command-option
</code></pre>

<h3>Assigning Values To Options.</h3>

<p>As a convention short options allow values directly after the option. When more than one
short option is used, you can not group a short option with a value together with other
short options.</p>

<p>The first example is correct, the second and third example should give an error.</p>

<pre><code class="bash">$ command -st -v value -w other
$ command -stv value
$ command -s=value
</code></pre>

<p>Long options can be assigned values by adding an equals sign and the value.</p>

<pre><code class="bash">$ command --long-option=value --other-long-option=other
</code></pre>

<p>When there is no equals sign the value will be interpreted as either the subcommand or the
first non option argument.</p>

<p>Options can be assigned values multiple times.</p>

<pre><code class="bash">$ command --long-option=first --long-option=second
$ command --long-option=first,second
</code></pre>

<h3>Boolean Options</h3>

<p>Allow for boolean options. As a convention allow the <code>not-</code> prefix to negate the option
when it is a boolean value. Do not allow <code>--not-option=false</code> or <code>--not-option=true</code>.</p>

<pre><code class="bash">$ command --enabled
$ command --not-enabled
$ command --enabled=true
$ command --enabled=false
</code></pre>

<h1>Classes</h1>

<h2>Option</h2>

<p>An Interface describing the options a valid option on the commandline.</p>

<pre><code class="java">public interface Option&lt;T&gt; {
    public boolean matches (String representation);
    public T validateValue (String value) throws WrongValueException;
    public boolean isRequired ();

    public String getRepresentation ();
    public String getDescription ();

    public boolean hasShortRepresentation ();
    public String getShortRepresentation ();
}
</code></pre>

<p>When calling <code>option.getRepresentation ()</code> the string that is returned is always the
representation with dashes (<code>long-option</code> instead of <code>long option</code>).</p>

<p>Three implementations are provided <code>BasicOption</code>, <code>ValueOption</code> and <code>BooleanOption</code>. They
all have constructors with a long representation and a constructor with both a long and
short representation. You can provide an extra boolean indicating whether the option is
required or not. By default options are not required.</p>

<pre><code class="java">Option basic = BasicOption (&quot;basic option&quot;);
Option value = ValueOption (&quot;required value&quot;, true);
Option bool = BooleanOption (&quot;required boolean&quot;, &quot;b&quot;, true);
</code></pre>

<p>Options should equal each other if the have the same long representation. If the long
representation is the same, the short representations should also be the same. Long
representations can be written either with spaces or with dashes.</p>

<pre><code class="java">Option spaces = new BasicOption (&quot;long option&quot;);
Option dashes = new BasicOption (&quot;long-option&quot;);

assertThat (spaces.equals (dashes), is (true));
</code></pre>

<h2>Argument</h2>

<pre><code class="java">public interface Argument {
    public T validateArgument (String arg);
    public boolean isRequired ();
    public String getRepresentation ();
    public int getPosition ();
}
</code></pre>

<h2>SubCommand</h2>

<pre><code class="java">public interface SubCommand {
    public boolean matches (String representation);
    public String getRepresentation ();
    public OptionScheme getOptionScheme ();
}
</code></pre>

<p>One implementation is provided (<code>SubCommandImpl</code>). It can be instantiated with a string
representing the subcommand, or with a string and an options scheme.</p>

<pre><code class="java">SubCommand command = new SubCommandImpl (&quot;sub&quot;);

OptionScheme scheme = new CustomOptionsScheme ();
SubCommand command = new SubCommandImpl (&quot;sub&quot;, scheme);
</code></pre>

<h2>OptionScheme</h2>

<p>This class is used to build up a scheme that is used to validate commandline arguments
against. It should also provide a nice <code>toString ()</code> method, to output a useful
description of the options that are allowed, and what they do.</p>

<p>When a subcommand is used, the paser should handle two schemes, the one used for the
global command, and the scheme for the subcommand. The structure for both is the same.</p>

<pre><code class="java">public interface OptionScheme {
    public boolean hasOption (String representation);
    public boolean hasOption (Option option);

    // The string representation should be useful
    // when printed out to stdout.
    public String toString ();
}
</code></pre>

<p>One implementation is provided. This options scheme can be instantiated and the build by
adding new options to it.</p>

<pre><code class="java">public class OptionSchemeImpl {
    public void add (Option option);
    public void add (Argument argument);
}
</code></pre>

<p>When an options scheme is used as a global options scheme it is not allowed to provide
arguments.</p>

<pre><code class="java">public class GlobalOptionScheme {
    public void add (Option option);
}
</code></pre>

<h2>ParsedOptions</h2>

<pre><code class="java">public interface ParsedOptions {
    // See whether an option was provided on the command line or not.
    public boolean isPresent (String representation);
    public boolean isPresent (Option option);

    // get the value assigned to an option.
    public String getValue (String representation);
    public String getValue (Option option);

    // get arguments that did not parse as options.
    public String getArg (int position);
    public String getArg (Argument argument);
}
</code></pre>

<h2>Parser</h2>

<p>An Interface for parsers.</p>

<pre><code class="java">public interface Parser {
    public void parse (String [] args);
    public boolean hasSubCommand ();
    public String getSubCommand ();
    public ParsedOptions getOptions ();
    public ParsedOptions getGlobalOoptions ();
}
</code></pre>

<p>One parser implementation is provided (<code>ParserImpl</code>).</p>

<p>It can be instantiated with a list of subcommands. In this case there are no global
options allowed. Recall that when a subcommand can be used, a subcommand has to be used
for all valid <code>String [] args</code> sequences.</p>

<pre><code class="java">List&lt;SubCommand&gt; commands = buildSubCommandList ();
Parser parser = new ParserImpl (commands);
</code></pre>

<p>It can be instantiated with a single options scheme. In this case no
subcommands are allowed and the options scheme will be treathed as the global options
scheme.</p>

<pre><code class="java">OptionScheme scheme = new CustomOptionScheme ();
Parser parser = new ParserImpl (scheme);
</code></pre>

<p>It can be instantiated with an options scheme and a list op subcommands. This
is the same as a list of subcommands except that global options are now allowed, and are
specified by the options scheme given to <code>ParserImpl</code>.</p>

<pre><code class="java">List&lt;SubCommand&gt; commands = buildSubCommandList ();
OptionScheme scheme = new CustomOptionScheme ();
Parser parser = new ParserImpl (scheme, commands);
</code></pre>

<h1>Example</h1>

<p>Suppose we want the following command to be valid.</p>

<pre><code class="bash">$ command -st -u short sub --long-option=long path/to/file
</code></pre>

<p>We first need to specify that these options are valid. For this we build an
<code>OptionScheme</code>. This will contain all the information needed to validate and parse the
command line arguments.</p>

<pre><code class="java">SchemeBuilder schemeBuilder = new SchemeBuilder ();

schemeBuilder.add (new BasicOption (&quot;long option&quot;));
schemeBuilder.add (new BasicOption (&quot;short option&quot;, &quot;s&quot;));
schemeBuilder.add (new ValueOption (&quot;with value&quot;));
schemeBuilder.add (new BooleanOption (&quot;enable&quot;);
schemeBuilder.add (new Argument (&quot;path&quot;, 0));

OptionScheme scheme = schemeBuilder.buildScheme ();
</code></pre>

<p>When Using this in a program it could look something like this.</p>

<pre><code class="java">public static main (String [] args) {
    OptionScheme scheme = buildScheme ();
    Parser parser = new ParserImpl (scheme);

    parser.parse (args);
    ParsedOptions options = parser.getOptions ();

    assertThat (options.isPresent (&quot;long option&quot;), is (true));
    assertThat (options.getValue (&quot;long option&quot;), is (&quot;long&quot;));

    assertThat (options.isPresent (&quot;s&quot;), is (true));
    assertThat (options.getValue (&quot;s&quot;), is (&quot;short&quot;));

    assertThat (options.getArg (0), is (&quot;path/to/file&quot;));
    assertThat (options.getArg (&quot;path&quot;), is (&quot;path/to/file&quot;));
}

private static OptionScheme buildScheme () {
    SchemeBuilder schemeBuilder = new SchemeBuilder ();
    ...
    return scheme;
}

</code></pre>

<p>When parsing the following command.</p>

<pre><code class="bash">$ command --long-option sub --sub-option
</code></pre>

<pre><code class="java">public static main (String [] args) {
    OptionScheme scheme = buildScheme ();
    Parser parser = new ParserImpl (scheme);

    parser.parse (args);

    assertThat (parser.hasCommand (), is (true));
    assertThat (parser.getCommand (), is (&quot;sub&quot;));

    ParsedOptions options = parser.getOptions ();
    assertThat (options.isPresent (&quot;long option&quot;), is (false));
    assertThat (options.isPresent (&quot;sub option&quot;), is (true));

    ParsedOptions subOptions = parser.getGlobalOptions ();
    assertThat (subOptions.isPresent (&quot;long option&quot;), is (true));
    assertThat (subOptions.isPresent (&quot;sub option&quot;), is (false));
}

public static OptionScheme buildScheme () {

}
</code></pre>

<h1>Possible extras?</h1>

<ul>
<li>A way to indicate that one of a group of options is mandatory, for instance such as the
tar command. It needs either an x, c, ... .</li>
</ul>
</body></html>
